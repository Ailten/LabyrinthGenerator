<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Labyrinth Generator (JS)</title>
		<meta charset="UTF-8"/>
		<style>
			body{
				margin: 0;
				background-color: grey;
			}
			h1, h2, h3 {
				text-align: center;
				margin: 6px 0;
			}
			
			.flex-container {
				display: flex;
			}
			.flex-container > * {
				flex: 1;
			}
			
			section {
				border-top: 1px solid #000;
			}
			
			section article {
				width: 50%;
				align: inline-block;
			}
			section article:nth-child(n+2) {
				border-left: 1px solid #000;
			}
			
			.div-input-section {
				position: absolute;
				width: 100%;
				text-align: center;
				padding-top: 6px;
			}
			.div-input-section > input {
				background-color: #9b9b9b;
				border: 1px solid black;
			}
			.div-input-section > input:hover,
			.div-input-section > input:active {
				background-color: #c0c0c0;
				border: 1px solid white;
			}
			
			article > textarea {
				width: -webkit-fill-available;
				background-color: #9b9b9b;
				border: none;
			}
			article > textarea:hover,
			article > textarea:active,
			article > textarea:focus {
				outline: none;
				background-color: #c0c0c0;
			}
			
			article > canvas {
				width: -webkit-fill-available;
				background-color: #6e6e6e;
			}
			
		</style>
		<script>
		
			const canvasWidth = 1280; //resolution canvas.
			const canvasHeight = 720;
			
			const cellWidth = 30; //size cell.
			const cellHeight = 30;
		
			window.addEventListener('load', function(){
			
				let sections = document.getElementsByTagName('section'); //load data for all sections.
				for(let s=0; s<sections.length; s++){
				
					let titleSection = sections[s].getElementsByTagName('h2')[0]; //adapt title section.
					titleSection.innerText = 'step '+ (s+1) +' : ' + titleSection.innerText;
					
					let input = sections[s].getElementsByTagName('input')[0]; //adapt input apply.
					input.setAttribute('data-id-section', s);
				
					let code = codeStr[s]
						.replace(/(^\n|\n$)/g, '') //sanitise start and end.
						.replace(/	/g, '  '); //replace indentation.
					let codeRows = code.split(/\n/g).length;
				
					let textarea = sections[s].getElementsByTagName('textarea')[0];
					textarea.innerHTML = code;
					textarea.setAttribute('rows', codeRows);
					textarea.setAttribute('spellcheck', 'false');
					
					eval(code); //execute code.
					
					let canvas = sections[s].getElementsByTagName('canvas')[0]; //draw on canvas.
					canvas.setAttribute('width', canvasWidth);
					canvas.setAttribute('height', canvasHeight);
					let c2d = canvas.getContext('2d');
					drawGrid(c2d, grid);
					
				}
				
			});
			
			function drawGrid(c2d, grid){
				c2d.clearRect( //clean canvas.
					0, 0,
					canvasWidth, canvasHeight
				);
			
				let xCenter = canvasWidth/2;
				let yCenter = canvasHeight/2;
				let gridWidth = (grid[0].length*cellWidth)/2;
				let gridHeight = (grid.length*cellHeight)/2;
				for(let y=0; y<grid.length; y++)
				for(let x=0; x<grid[y].length; x++){
					let posCellX = (xCenter - gridWidth) + cellWidth*x;
					let posCellY = (yCenter - gridHeight) + cellHeight*y;
					
					c2d.fillStyle = grid[y][x].color; //draw cell.
					c2d.fillRect(
						posCellX, 
						posCellY, 
						cellWidth, 
						cellHeight
					);
					
					if(grid[y][x].idRng != null){ //draw idRng.
						c2d.font = '20px Trebuchet MS';
						c2d.fillStyle = 'blue';
						c2d.textAlign = 'center';
						c2d.textBaseline = 'middle';
						c2d.fillText(
							grid[y][x].idRng, 
							posCellX + cellWidth/2,
							posCellY + cellHeight/2
						);
					}
					
				}
			}
			
			function apply(input) {
				let s = input.getAttribute('data-id-section'); //get id.
				let sections = document.getElementsByTagName('section'); //get section.
				
				for(let i=0; i<=s; i++){ //loop on section from zero to selected.
					let textarea = sections[i].getElementsByTagName('textarea')[0];
					let code = textarea.value
						.replace(/&lt;/g, '<')
						.replace(/&amp;/g, '&');
					eval(code); //execute textarea contend.
					
					let canvas = sections[i].getElementsByTagName('canvas')[0]; //re-draw canvas.
					let c2d = canvas.getContext('2d');
					drawGrid(c2d, grid);
					
					console.log(grid);
				}
					
			}
			
			const codeStr = [
`
let width = 7; //size of labyrinth we want (rooms).
let height = 5;

let widthNWall = width * 2 + 1; //size of labyrinth (rooms+walls).
let heightNWall = height * 2 + 1;

var grid = []; //array 2D fill (of object).
for(let y=0; y<heightNWall; y++){
	grid.push([]); //push a new line in row array.
	for(let x=0; x<widthNWall; x++){
		if(x%2 != 0 && y%2 != 0) //add room.
			grid[y].push({type: 'room', color:'white', idRng: null});
		else if(x%(widthNWall-1) == 0 || y%(heightNWall-1) == 0) //add border.
			grid[y].push({type: 'border', color:'black', idRng: null});
		else if(x%2 == 0 && y%2 == 0) //add center.
			grid[y].push({type: 'center', color:'black', idRng: null});
		else //add wall.
			grid[y].push({type: 'wall', color:'grey', idRng: null});
	}
}
`,`
Math.randomNumLowerThan = function(max){
	return Math.floor(Math.random() * max);
};

let arrayNumberSend = [];
for(let y=0; y<grid.length; y++){
	for(let x=0; x<grid[0].length; x++){
		if(grid[y][x].type != 'room')
			continue; //take only room.
	
		let randNum;
		do{ //get a random number not already assigned to a room.
			randNum = Math.randomNumLowerThan(
				grid.length * grid[0].length
			); //set a bigger range than room count.
		}while(arrayNumberSend.includes(randNum));
			
		grid[y][x].idRng = randNum; //set the id.
		arrayNumberSend.push(randNum); //stock id send.
	}
}
`,`
let isStayOnLoop = true;
while(isStayOnLoop){

	let randY = Math.randomNumLowerThan(grid.length); //random cell in grid.
	let randX = Math.randomNumLowerThan(grid[0].length);
	if(grid[randY][randX].type != 'wall')
		continue; //skip if not a wall.
	
	let roomOneY = randY; //position cell of both room join by the wall.
	let roomOneX = randX;
	let roomTwoY = randY;
	let roomTwoX = randX;
	if(randX%2 == 0){ //is a vertical wall.
		roomOneX -= 1;
		roomTwoX += 1;
	}else{ //is an horizontal wall.
		roomOneY -= 1;
		roomTwoY += 1;
	}
	
	let roomOneId = grid[roomOneY][roomOneX].idRng; //get both idRng.
	let roomTwoId = grid[roomTwoY][roomTwoX].idRng;
	
	if(roomOneId == roomTwoId) //if the two room have the same id.
		continue; //skip, (the two room is already connected).
		
	//cast/replace object wall by an object path.
	grid[randY][randX] = {type: 'path', color:'white', idRng: null};
	
	isStayOnLoop = false; //default, expect exit the loop.
	for(let y=0; y<grid.length; y++){
		for(let x=0; x<grid[0].length; x++){
			if(grid[y][x].type != 'room')
				continue; //take only room.
			
			if(grid[y][x].idRng == roomTwoId) //if id equal idTwo.
				grid[y][x].idRng = roomOneId; //replace by idOne.
			
			if(grid[y][x].idRng != roomOneId) //if find a room with dif number.
				isStayOnLoop = true; //stay on loop, need to break other wall.
			
		}
	}

}
`,`
let startY = 1; //choose a room to start.
let startX = 1;
let endY = grid.length -2; //choose a room to end.
let endX = grid[0].length -2;

let walkerLeftY = startY; //set two walker at room start.
let walkerLeftX = startX;
let walkerRightY = startY;
let walkerRightX = startX;

let cellAdjacent = [ //array of cell adjacent (in clockwise direction).
	{x:  0, y: -1},
	{x:  1, y:  0},
	{x:  0, y:  1},
	{x: -1, y:  0}
];
let lastDirectionLeft = 1; //last index direction take.
let lastDirectionRight = 2;

for(let y=0; y<grid.length; y++){ //reset id of all cell.
	for(let x=0; x<grid[0].length; x++){
		if(grid[y][x].type == 'room' || grid[y][x].type == 'path')
			grid[y][x].idRng = 0;
	}
}

while(true){ //loop until both walker walk on the end room.

	if(grid[walkerLeftY][walkerLeftX].idRng%2 < 1) //if walker have never walk on.
		grid[walkerLeftY][walkerLeftX].idRng += 1; //mark walk by walker left.
	if(grid[walkerRightY][walkerRightX].idRng < 2) //same for walker right.
		grid[walkerRightY][walkerRightX].idRng += 2; //using value 2^1 for right.
	
	if(grid[walkerLeftY][walkerLeftX].idRng == 3) //if mark walk by both walker.
		grid[walkerLeftY][walkerLeftX].color = 'gold'; //color on gold.
	if(grid[walkerRightY][walkerRightX].idRng == 3) //same for walker right.
		grid[walkerRightY][walkerRightX].color = 'gold';
		
	if(grid[endY][endX].idRng == 3) //exit the loop.
		break;
	
	if(walkerLeftY != endY || walkerLeftX != endX){ //if walker not at end.
		let replaceI = lastDirectionLeft -1; //rotate direction base on last.
		for(let i=0; i<cellAdjacent.length; i++){ //loop until find a walkable.
			let index = (i + replaceI +cellAdjacent.length) %cellAdjacent.length;
			let walfLeftDestinationY = walkerLeftY + cellAdjacent[index].y;
			let walfLeftDestinationX = walkerLeftX + cellAdjacent[index].x;
			let cellDestination = grid[walfLeftDestinationY][walfLeftDestinationX];
			if(cellDestination.type == 'room' || cellDestination.type == 'path'){
				walkerLeftY = walfLeftDestinationY; //apply new pos of walker left.
				walkerLeftX = walfLeftDestinationX;
				lastDirectionLeft = index; //update the last direction.
				break; //find next cell destination of walker left.
			}
		}
	}
	
	if(walkerRightY != endY || walkerRightX != endX){ //same for walker right.
		let replaceI = lastDirectionRight +1; //rotate reverce for right.
		for(let i=0; i>-cellAdjacent.length; i--){ //loop in reverce order.
			let index = (i + replaceI +cellAdjacent.length) %cellAdjacent.length;
			let walfRightDestinationY = walkerRightY + cellAdjacent[index].y;
			let walfRightDestinationX = walkerRightX + cellAdjacent[index].x;
			let cellDestination = grid[walfRightDestinationY][walfRightDestinationX];
			if(cellDestination.type == 'room' || cellDestination.type == 'path'){
				walkerRightY = walfRightDestinationY;
				walkerRightX = walfRightDestinationX;
				lastDirectionRight = index;
				break;
			}
		}
	}
	
}
`
			];
			
		</script>
	</head>
	<body>
		<h1>Labyrinth Generator (JS)</h1>
		<section>
			<h2>the grid</h2>
			<div class="div-input-section">
				<input type="button" value="apply" onclick="apply(this)"/>
			</div>
			<div class="flex-container">
				<article>
					<h3>code</h3>
					<textarea></textarea>
				</article>
				<article>
					<h3>result</h3>
					<canvas></canvas>
				</article>
			</div>
		</section>
		<section>
			<h2>random number</h2>
			<div class="div-input-section">
				<input type="button" value="apply" onclick="apply(this)"/>
			</div>
			<div class="flex-container">
				<article>
					<h3>code</h3>
					<textarea></textarea>
				</article>
				<article>
					<h3>result</h3>
					<canvas></canvas>
				</article>
			</div>
		</section>
		<section>
			<h2>break walls</h2>
			<div class="div-input-section">
				<input type="button" value="apply" onclick="apply(this)"/>
			</div>
			<div class="flex-container">
				<article>
					<h3>code</h3>
					<textarea></textarea>
				</article>
				<article>
					<h3>result</h3>
					<canvas></canvas>
				</article>
			</div>
		</section>
		<section>
			<h2>the hanswer</h2>
			<div class="div-input-section">
				<input type="button" value="apply" onclick="apply(this)"/>
			</div>
			<div class="flex-container">
				<article>
					<h3>code</h3>
					<textarea></textarea>
				</article>
				<article>
					<h3>result</h3>
					<canvas></canvas>
				</article>
			</div>
		</section>
	</body>
</html>